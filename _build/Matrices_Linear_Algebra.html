---
redirect_from:
  - "/matrices-linear-algebra"
interact_link: content/Matrices_Linear_Algebra.ipynb
kernel_name: julia-1.3
has_widgets: false
title: |-
  Linear Algebra
prev_page:
  url: /Recursion-Divide-and-Conquer.html
  title: |-
    Recursion
next_page:
  url: /Strings_Files.html
  title: |-
    String Files
suffix: .ipynb

comment: "***PROGRAMMATICALLY GENERATED, DO NOT EDIT. SEE ORIGINAL FILES IN /content***"
---

    <main class="jupyter-page">
    <div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Matrix-operations,-linear-algebra">Matrix operations, linear algebra<a class="anchor-link" href="#Matrix-operations,-linear-algebra"> </a></h1>
</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Vectors-and-matrices">Vectors and matrices<a class="anchor-link" href="#Vectors-and-matrices"> </a></h3><p>We have already seen how to create 1D and 2D arrays in Julia. These can be naturally used to represent vectors and matrices:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>   <span class="c"># Random vector</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>3-element Array{Float64,1}:
 -0.021772996308672583
 -1.1931325025911688  
  1.6158391973078738  </pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="c"># Random matrix</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>3×3 Array{Float64,2}:
  0.0577623  -1.34468    0.3378   
 -0.240045   -0.468172  -2.62513  
 -0.198912   -0.862207   0.0531239</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Matrix-operations">Matrix operations<a class="anchor-link" href="#Matrix-operations"> </a></h3><p>Julia also defines common matrix operations for arrays, some in the base library and some in the <code>LinearAlgebra</code> package.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="k">using</span> <span class="n">LinearAlgebra</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>For example addition, subtraction, and scalar multiplication work as expected:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">y</span> <span class="o">=</span> <span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">x</span> <span class="o">-</span> <span class="mi">3</span><span class="n">y</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>3-element Array{Float64,1}:
 -2.746128145913699 
  0.6238207409805658
  7.5441095073109015</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Note that this happens to be the same operation as the corresponding <em>elementwise</em> operation <code>x .- 3y</code>, because of the definition of vector addition. However, if you try to multiply two vectors</p>
<div class="highlight"><pre><span></span><span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>   <span class="c"># Error - cannot multiply two vectors</span>
</pre></div>
<p>you get an error. Use can use the <code>dot</code> function or the $\cdot$ syntax (type <code>\cdot</code> and tab) to compute dot products:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">x_dot_y_1</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>   <span class="c"># Dot product</span>
<span class="n">x_dot_y_2</span> <span class="o">=</span> <span class="n">x</span> <span class="o">⋅</span> <span class="n">y</span>      <span class="c"># Same thing</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>-2.4901943143871237</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>For the special case of vectors of length 3, Julia also defines the cross product:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">x_cross_y</span> <span class="o">=</span> <span class="n">cross</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>3-element Array{Float64,1}:
 3.336372087216575 
 1.4243478768476163
 1.096692397953567 </pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The 2-norm of a vector can be calculated using the <code>norm</code> function:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>                 <span class="c"># 2-norm of x</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">sum</span><span class="p">(</span><span class="n">abs</span><span class="o">.</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span><span class="p">))</span>   <span class="c"># Should be the same</span>
<span class="n">a</span> <span class="o">-</span> <span class="n">b</span>                       <span class="c"># Confirm</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>0.0</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>More generally, the <code>norm</code> function takes a second argument <code>p</code> in which case it computes the $p$-norm:</p>
$$
\|A\|_p = \left( \sum_{i=1}^n | a_i | ^p \right)^{1/p}
$$<p>This includes the so-called max-norm, by setting <code>p</code> to <code>Inf</code>.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Matrix-multiplication">Matrix multiplication<a class="anchor-link" href="#Matrix-multiplication"> </a></h3><p>Matrix multiplication is performed using the <code>*</code> operator. Recall the definition of the product of two matrices $C=AB$ where $A$ is $m$-by-$k$, $B$ is $k$-by-$n$, and $C$ is $m$-by-$n$:</p>
$$
C_{ij} = \sum_{\ell=1}^k A_{i\ell} B_{\ell j},\qquad\text{ for }i=1,\ldots,m\text{ and }j=1,\ldots,n
$$<p>If the "middle dimensions" ($k$ in the example above) do not match, Julia gives an error.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">B</span> <span class="o">=</span> <span class="n">randn</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">B</span><span class="o">*</span><span class="n">A</span>     <span class="c"># OK, since B is 4-by-3 and A is 3-by-3</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>4×3 Array{Float64,2}:
 -0.341603   -2.17688   -0.631939
 -0.0467917  -2.11816   -1.3882  
  0.0630553   0.108865  -2.23194 
 -0.0452437   0.700564   2.31513 </pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Note that unlike addition and subtraction, matrix multiplication is completely different from elementwise multiplication:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">AA</span> <span class="o">=</span> <span class="n">A</span><span class="o">*</span><span class="n">A</span>     <span class="c"># Square of matrix</span>
<span class="n">A2</span> <span class="o">=</span> <span class="n">A</span><span class="o">.*</span><span class="n">A</span>    <span class="c"># Square of each entry in matrix</span>
<span class="n">A2</span> <span class="o">-</span> <span class="n">AA</span>      <span class="c"># These are not the same</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>3×3 Array{Float64,2}:
 -0.25559    1.54754   -3.4533 
 -0.563065  -2.58619    5.88285
 -0.145346   0.118072  -2.19622</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Similarly, the power <code>^</code> operator will compute <em>matrix powers</em>, not elementwise powers:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">A_to_the_power_of_2</span> <span class="o">=</span> <span class="n">A</span><span class="o">^</span><span class="mi">2</span>       <span class="c"># Same as A*A</span>
<span class="n">A_to_the_power_of_3_5</span> <span class="o">=</span> <span class="n">A</span><span class="o">^</span><span class="mf">3.5</span>   <span class="c"># A^3.5, much harder to compute!</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>3×3 Array{Complex{Float64},2}:
 -0.207366-0.815999im  -1.32916-3.24675im    2.9191-4.18515im
  0.171307-1.36995im    1.01232-5.45083im  -2.23925-7.02627im
 -0.092465-0.681746im  -0.52618-2.71258im   1.16802-3.49659im</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Note that Julia automatically returns a matrix of complex numbers when needed (even if the input matrix was real).</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Matrix-transpose">Matrix transpose<a class="anchor-link" href="#Matrix-transpose"> </a></h3><p>Matrices can be transposed using the <code>transpose</code> function, or conjugate transposed using the <code>adjoint</code> function or the convenient <code>'</code> syntax:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">BT</span> <span class="o">=</span> <span class="n">transpose</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>     <span class="c"># B is 4-by-3, so BT is 3-by-4</span>
<span class="n">BT2</span> <span class="o">=</span> <span class="n">B</span><span class="o">&#39;</span>              <span class="c"># Same thing (since B is real so conjugate does not matter)</span>

<span class="n">A</span> <span class="o">*</span> <span class="n">B</span><span class="o">&#39;</span>                <span class="c"># Well-defined, since A is 3-by-3 and B&#39; is 3-by-4</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>3×4 Array{Float64,2}:
  0.0673377  -0.941458  -1.58155    1.64532
 -4.14456    -0.154658   2.78497   -2.31816
 -0.328539   -0.914381  -0.907507   1.08381</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Since the dot product between two vectors can be written as $z = x^*y$ (conjugate transpose of $x$), matrix multiplication can be used to provide an alternative syntax:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">x_dot_y_3</span> <span class="o">=</span> <span class="n">x</span><span class="o">&#39;</span> <span class="o">*</span> <span class="n">y</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>-2.4901943143871237</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>In all these examples, the vectors <code>x</code> and <code>y</code> have been 1D arrays. It is also possible to use 2D arrays (or matrices) to represent vectors, which allows for both column- and row-vectors:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>   <span class="c"># Column vector</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>   <span class="c"># Row vector</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>1×3 Array{Float64,2}:
 -0.491693  -0.557039  0.866311</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Note that <code>a' * b</code> is now invalid because of the dimensions. One option is to do <code>a' * b'</code>, but it is generally safer to use the <code>dot</code> function to compute the dot product:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">a_dot_b</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>-0.3912342051292812</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Special-matrices">Special matrices<a class="anchor-link" href="#Special-matrices"> </a></h3><p>The 2D arrays shown above have been general, that is, that can be used to represent arbitrary matrices. Many applications lead to matrices with special structures or properties, and Julia defines a number of specialized matrix representations for this. The main reason for using these is to obtain better performance (which can make a very big difference), but they are also useful to e.g. ensure correctness of codes by enforcing known properties.</p>
<table>
<thead><tr>
<th style="text-align:left">Type</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Symmetric</td>
<td style="text-align:left"><a href="https://en.wikipedia.org/wiki/Symmetric_matrix">Symmetric matrix</a></td>
</tr>
<tr>
<td style="text-align:left">Hermitian</td>
<td style="text-align:left"><a href="https://en.wikipedia.org/wiki/Hermitian_matrix">Hermitian matrix</a></td>
</tr>
<tr>
<td style="text-align:left">UpperTriangular</td>
<td style="text-align:left">Upper <a href="https://en.wikipedia.org/wiki/Triangular_matrix">triangular matrix</a></td>
</tr>
<tr>
<td style="text-align:left">UnitUpperTriangular</td>
<td style="text-align:left">Upper <a href="https://en.wikipedia.org/wiki/Triangular_matrix">triangular matrix</a> with unit diagonal</td>
</tr>
<tr>
<td style="text-align:left">LowerTriangular</td>
<td style="text-align:left">Lower <a href="https://en.wikipedia.org/wiki/Triangular_matrix">triangular matrix</a></td>
</tr>
<tr>
<td style="text-align:left">UnitLowerTriangular</td>
<td style="text-align:left">Lower <a href="https://en.wikipedia.org/wiki/Triangular_matrix">triangular matrix</a> with unit diagonal</td>
</tr>
<tr>
<td style="text-align:left">Tridiagonal</td>
<td style="text-align:left"><a href="https://en.wikipedia.org/wiki/Tridiagonal_matrix">Tridiagonal matrix</a></td>
</tr>
<tr>
<td style="text-align:left">SymTridiagonal</td>
<td style="text-align:left">Symmetric tridiagonal matrix</td>
</tr>
<tr>
<td style="text-align:left">Bidiagonal</td>
<td style="text-align:left">Upper/lower <a href="https://en.wikipedia.org/wiki/Bidiagonal_matrix">bidiagonal matrix</a></td>
</tr>
<tr>
<td style="text-align:left">Diagonal</td>
<td style="text-align:left"><a href="https://en.wikipedia.org/wiki/Diagonal_matrix">Diagonal matrix</a></td>
</tr>
<tr>
<td style="text-align:left">UniformScaling</td>
<td style="text-align:left"><a href="https://en.wikipedia.org/wiki/Uniform_scaling">Uniform scaling operator</a></td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>For example, if you know that your matrix is both symmetric and tridiagonal, you can use the <code>SymTridiagonal</code> type. The example below shows how to generate a famous matrix which is very common in applications:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="kt">SymTridiagonal</span><span class="p">(</span><span class="mi">2</span><span class="n">ones</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="o">-</span><span class="n">ones</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>5×5 SymTridiagonal{Float64,Array{Float64,1}}:
  2.0  -1.0    ⋅     ⋅     ⋅ 
 -1.0   2.0  -1.0    ⋅     ⋅ 
   ⋅   -1.0   2.0  -1.0    ⋅ 
   ⋅     ⋅   -1.0   2.0  -1.0
   ⋅     ⋅     ⋅   -1.0   2.0</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The matrix operations defined above will work just as before on these specialized types, but likely be much more efficient. For example:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">T</span> <span class="o">*</span> <span class="n">randn</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>     <span class="c"># Matrix-vector multiplication</span>
<span class="n">T</span><span class="o">^</span><span class="mi">3</span>              <span class="c"># Matrix cube</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>5×5 Array{Float64,2}:
  14.0  -14.0    6.0   -1.0    0.0
 -14.0   20.0  -15.0    6.0   -1.0
   6.0  -15.0   20.0  -15.0    6.0
  -1.0    6.0  -15.0   20.0  -14.0
   0.0   -1.0    6.0  -14.0   14.0</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="The-identity-matrix">The identity matrix<a class="anchor-link" href="#The-identity-matrix"> </a></h3><p>The identity matrix $I$ is so commonly used, that it has a special syntax which supports some additional performance improvements. In its simplest form, you can simply use the <code>I</code> operator and it will behave as expected:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">T</span> <span class="o">+</span> <span class="mi">2</span><span class="nb">I</span>     <span class="c"># OK, since T is 3-by-3</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>5×5 SymTridiagonal{Float64,Array{Float64,1}}:
  4.0  -1.0    ⋅     ⋅     ⋅ 
 -1.0   4.0  -1.0    ⋅     ⋅ 
   ⋅   -1.0   4.0  -1.0    ⋅ 
   ⋅     ⋅   -1.0   4.0  -1.0
   ⋅     ⋅     ⋅   -1.0   4.0</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>If you want to actually create an identity matrix, you have to specify the element type and the dimensions:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">I4</span> <span class="o">=</span> <span class="kt">Matrix</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}(</span><span class="nb">I</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>4×4 Array{Float64,2}:
 1.0  0.0  0.0  0.0
 0.0  1.0  0.0  0.0
 0.0  0.0  1.0  0.0
 0.0  0.0  0.0  1.0</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>but this is often not necessary since the <code>I</code> operator can be used in expressions, as shown above.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Linear-systems">Linear systems<a class="anchor-link" href="#Linear-systems"> </a></h2><p>One of the most common uses of matrices is for solving linear systems of equations. Julia uses the backslash operator <code>\</code> for this:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">A</span> <span class="o">\</span> <span class="n">b</span>         <span class="c"># Solve Ax = b for x</span>
<span class="n">A</span><span class="o">*</span><span class="n">x</span> <span class="o">==</span> <span class="n">b</span>        <span class="c"># Confirm solution is correct</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>true</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>One way to view the syntax <code>A\b</code> is that it multiplies by <code>A</code>-inverse from the left, but using much more efficient and accurate algorithms.</p>
<p>For systems with many right-hand side vectors <code>b</code>, the <code>\</code> operator also works with matrices:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">B</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span> <span class="mi">7</span><span class="p">;</span> <span class="mi">1</span> <span class="o">-</span><span class="mi">3</span><span class="p">]</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">A</span> <span class="o">\</span> <span class="n">B</span>          <span class="c"># Solve for two RHS vectors</span>
<span class="n">A</span><span class="o">*</span><span class="n">X</span> <span class="o">==</span> <span class="n">B</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>true</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The algorithm used by the <code>\</code> operator is typically Gaussian elimination, but the details are quite complex depending on the type of matrices involved. Due to the high cost of general Gaussian elimination, it can make a big difference if you use a specialized matrix type:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="mi">2000</span>
<span class="n">T</span> <span class="o">=</span> <span class="kt">SymTridiagonal</span><span class="p">(</span><span class="mi">2</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="o">-</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>     <span class="c"># n-by-n symmetric tridiagonal</span>

<span class="k">for</span> <span class="n">rep</span> <span class="o">=</span> <span class="mi">1</span><span class="o">:</span><span class="mi">3</span> <span class="nd">@time</span> <span class="n">T</span> <span class="o">\</span> <span class="n">randn</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">end</span>       <span class="c"># Very fast since T is a SymTridiagonal</span>
<span class="n">Tfull</span> <span class="o">=</span> <span class="kt">Matrix</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>                          <span class="c"># Convert T to a full 2D array</span>
<span class="k">for</span> <span class="n">rep</span> <span class="o">=</span> <span class="mi">1</span><span class="o">:</span><span class="mi">3</span> <span class="nd">@time</span> <span class="n">Tfull</span> <span class="o">\</span> <span class="n">randn</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">end</span>   <span class="c"># Now \ is magnitudes slower</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>  0.039093 seconds (120.81 k allocations: 6.057 MiB, 11.71% gc time)
  0.000058 seconds (6 allocations: 63.047 KiB)
  0.000050 seconds (6 allocations: 63.047 KiB)
  0.289975 seconds (377.20 k allocations: 48.851 MiB, 18.46% gc time)
  0.161816 seconds (6 allocations: 30.564 MiB, 26.19% gc time)
  0.121922 seconds (6 allocations: 30.564 MiB, 1.86% gc time)
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The matrix <code>A</code> in <code>A\b</code> can also be rectangular, in which case a minimum-norm least squares solution is computed.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Example:-Linear-regression">Example: Linear regression<a class="anchor-link" href="#Example:-Linear-regression"> </a></h3><p>Suppose you want to approximate a set of $n$ points $(x_i,y_i)$, $i=1,\ldots,n$, by a straight line. The <em>least squares approximation</em> $y=a + bx$ is given by the least-squares solution of the following over-determined system:</p>
$$
\begin{pmatrix}
1 &amp; x_1 \\
1 &amp; x_2 \\
\vdots &amp; \vdots \\
1 &amp; x_n
\end{pmatrix}
\begin{pmatrix}
a \\ b
\end{pmatrix}=
\begin{pmatrix}
y_1 \\ y_2 \\ \vdots \\ y_n
\end{pmatrix}
$$
</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">:</span><span class="mf">0.1</span><span class="o">:</span><span class="mi">10</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="mi">3</span><span class="n">x</span> <span class="o">.-</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">randn</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>     <span class="c"># Example data: straight line with noise</span>

<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="n">x</span><span class="p">]</span>            <span class="c"># LHS</span>
<span class="n">ab</span> <span class="o">=</span> <span class="n">A</span> <span class="o">\</span> <span class="n">y</span>                 <span class="c"># Least-squares solution</span>

<span class="k">using</span> <span class="n">PyPlot</span>
<span class="n">xplot</span> <span class="o">=</span> <span class="mi">0</span><span class="o">:</span><span class="mi">10</span><span class="p">;</span>
<span class="n">yplot</span> <span class="o">=</span> <span class="err">@</span><span class="o">.</span> <span class="n">ab</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">ab</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">xplot</span>
<span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="s">&quot;.&quot;</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">xplot</span><span class="p">,</span> <span class="n">yplot</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">);</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea ">
<img src="images/Matrices_Linear_Algebra_48_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Other-matrix-operations">Other matrix operations<a class="anchor-link" href="#Other-matrix-operations"> </a></h3><p>The <code>LinearAlgebra</code> package defines many other common matrix operations. For example, determinant, trace, and inverse matrix (but note that inverse matrices are often inefficient and ill-conditioned, use <code>\</code> instead for solving linear systems):</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">println</span><span class="p">(</span><span class="s">&quot;det(A) = &quot;</span><span class="p">,</span> <span class="n">det</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="n">println</span><span class="p">(</span><span class="s">&quot;tr(A) = &quot;</span><span class="p">,</span> <span class="n">tr</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="n">println</span><span class="p">(</span><span class="s">&quot;inv(A) = &quot;</span><span class="p">,</span> <span class="n">inv</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>det(A) = 2.8687593898057506
tr(A) = 1.6278039667977091
inv(A) = [0.173381 0.536201 -0.102944; 0.320358 -0.6258 0.809713; -0.118417 -0.427549 -1.13546]
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Eigenvalues and eigenvectors can be computed using the functions <code>eigvals</code> and <code>eigvects</code>. Note that the output of these functions is in general complex, even though the matrices are real.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">lambda</span> <span class="o">=</span> <span class="n">eigvals</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>     <span class="c"># Eigenvalues</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>3-element Array{Float64,1}:
 -2.819664990699433 
  0.5695543688069462
  0.4618240881114363</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">eigvecs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>          <span class="c"># Eigenvectors</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>3×3 Array{Float64,2}:
  0.747638  -0.900207   -0.93696 
 -0.169621  -0.0649532  -0.165563
 -0.642079  -0.430591   -0.307724</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">X</span> <span class="o">-</span> <span class="n">X</span><span class="o">*</span><span class="kt">Diagonal</span><span class="p">(</span><span class="n">lambda</span><span class="p">))</span>     <span class="c"># Confirm A*X = X*LAMBDA</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>2.0930285233966152e-15</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Example:-Eigenvalues-of-random-matrices">Example: Eigenvalues of random matrices<a class="anchor-link" href="#Example:-Eigenvalues-of-random-matrices"> </a></h3><p>Random matrix theory studies the distribution of the eigenvalues of certain classes of randomly generated matrices, which have many important applications. For example, matrices with entries from the normal distribution can be shown to have eigenvalues concentrated inside a circle in the complex plane:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">randn</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
<span class="n">l</span> <span class="o">=</span> <span class="n">eigvals</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">real</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="n">imag</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="s">&quot;.&quot;</span><span class="p">)</span>
<span class="n">axis</span><span class="p">(</span><span class="s">&quot;equal&quot;</span><span class="p">);</span>
<span class="c"># Draw circle</span>
<span class="n">radius</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="n">phi</span> <span class="o">=</span> <span class="mi">2</span><span class="nb">π</span><span class="o">*</span><span class="p">(</span><span class="mi">0</span><span class="o">:</span><span class="mi">100</span><span class="p">)</span><span class="o">/</span><span class="mi">100</span>
<span class="n">plot</span><span class="p">(</span><span class="n">radius</span><span class="o">*</span><span class="n">cos</span><span class="o">.</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span> <span class="n">radius</span><span class="o">*</span><span class="n">sin</span><span class="o">.</span><span class="p">(</span><span class="n">phi</span><span class="p">));</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea ">
<img src="images/Matrices_Linear_Algebra_56_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Other-data-types">Other data types<a class="anchor-link" href="#Other-data-types"> </a></h3><p>We already saw how matrix operations can be performed on complex numbers. Many operations are also defined for rational numbers, which allows for exact linear algebra computations:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">num</span> <span class="o">=</span> <span class="n">rand</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="o">:</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">den</span> <span class="o">=</span> <span class="n">rand</span><span class="p">(</span><span class="mi">1</span><span class="o">:</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">rat</span> <span class="o">=</span> <span class="n">num</span> <span class="o">.//</span> <span class="n">den</span>
<span class="n">display</span><span class="p">(</span><span class="n">rat</span><span class="p">)</span>
<span class="n">inv</span><span class="p">(</span><span class="n">rat</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea ">
<pre>3×3 Array{Rational{Int64},2}:
 -5//9   7//10  -1//1 
  5//3   4//1    7//8 
 -5//7  -6//1   -9//10</pre>
</div>

</div>
</div>
<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>3×3 Array{Rational{Int64},2}:
   2772//11489  55692//57445    7749//11489
   1470//11489   -360//11489   -5950//34467
 -12000//11489  -6440//11489  -17080//34467</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

 


    </main>
    